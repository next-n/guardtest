import { EventEmitter } from 'node:events';

type HttpMethod = "GET" | "POST" | "PUT" | "PATCH" | "DELETE" | "HEAD" | "OPTIONS";
interface ResilientRequest {
    method: HttpMethod;
    url: string;
    headers?: Record<string, string>;
    body?: string | Uint8Array | Buffer;
}
interface ResilientResponse {
    status: number;
    headers: Record<string, string>;
    body: Uint8Array;
}
interface MicroCacheRetryOptions {
    maxAttempts?: number;
    baseDelayMs?: number;
    maxDelayMs?: number;
    retryOnStatus?: number[];
}
interface MicroCacheOptions {
    enabled: boolean;
    ttlMs?: number;
    maxStaleMs?: number;
    maxEntries?: number;
    maxWaiters?: number;
    followerTimeoutMs?: number;
    keyFn?: (req: ResilientRequest) => string;
    retry?: MicroCacheRetryOptions;
}
interface ResilientHttpClientOptions {
    maxInFlight: number;
    maxQueue: number;
    enqueueTimeoutMs: number;
    requestTimeoutMs: number;
    /**
     * GET-only micro-cache + request coalescing.
     */
    microCache?: MicroCacheOptions;
}

declare class ResilientHttpClient extends EventEmitter {
    private readonly opts;
    private readonly limiter;
    private readonly requestTimeoutMs;
    private readonly microCache?;
    private cache?;
    private inFlight?;
    private microCacheReqCount;
    private readonly cleanupEveryNRequests;
    constructor(opts: ResilientHttpClientOptions);
    request(req: ResilientRequest): Promise<ResilientResponse>;
    private cloneResponse;
    private maybeCleanupExpired;
    private evictIfNeeded;
    private isRetryableStatus;
    private computeBackoffMs;
    private fetchWithLeaderRetry;
    /**
     * Window behavior:
     * - 0..ttlMs: return cache (fresh)
     * - ttlMs..maxStaleMs: leader refreshes; others get old value until replaced (stale-while-revalidate)
     * - >maxStaleMs: do not serve old; behave like no cache
     *
     * Follower controls (only when no cache is served):
     * - maxWaiters: cap concurrent followers joining the leader
     * - followerTimeoutMs: shared "join window" from first follower; after it expires, late followers fail fast until leader completes
     */
    private requestWithMicroCache;
    private existingPipeline;
    snapshot(): {
        inFlight: number;
        queueDepth: number;
    };
}

declare abstract class ResilientHttpError extends Error {
    readonly name: string;
    constructor(message: string);
}
declare class QueueFullError extends ResilientHttpError {
    readonly maxQueue: number;
    constructor(maxQueue: number);
}
declare class QueueTimeoutError extends ResilientHttpError {
    readonly enqueueTimeoutMs: number;
    constructor(enqueueTimeoutMs: number);
}
declare class RequestTimeoutError extends ResilientHttpError {
    readonly requestTimeoutMs: number;
    constructor(requestTimeoutMs: number);
}
declare class UpstreamError extends ResilientHttpError {
    readonly status: number;
    constructor(status: number);
}

export { type HttpMethod, type MicroCacheOptions, type MicroCacheRetryOptions, QueueFullError, QueueTimeoutError, RequestTimeoutError, ResilientHttpClient, type ResilientHttpClientOptions, ResilientHttpError, type ResilientRequest, type ResilientResponse, UpstreamError };
