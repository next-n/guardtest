"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/index.ts
var src_exports = {};
__export(src_exports, {
  QueueFullError: () => QueueFullError,
  QueueTimeoutError: () => QueueTimeoutError,
  RequestTimeoutError: () => RequestTimeoutError,
  ResilientHttpClient: () => ResilientHttpClient,
  ResilientHttpError: () => ResilientHttpError,
  UpstreamError: () => UpstreamError
});
module.exports = __toCommonJS(src_exports);

// src/client.ts
var import_node_events = require("events");

// src/errors.ts
var ResilientHttpError = class extends Error {
  name;
  constructor(message) {
    super(message);
    this.name = this.constructor.name;
  }
};
var QueueFullError = class extends ResilientHttpError {
  constructor(maxQueue) {
    super(`Queue is full (maxQueue=${maxQueue}).`);
    this.maxQueue = maxQueue;
  }
};
var QueueTimeoutError = class extends ResilientHttpError {
  constructor(enqueueTimeoutMs) {
    super(`Queue wait exceeded (enqueueTimeoutMs=${enqueueTimeoutMs}).`);
    this.enqueueTimeoutMs = enqueueTimeoutMs;
  }
};
var RequestTimeoutError = class extends ResilientHttpError {
  constructor(requestTimeoutMs) {
    super(`Request timed out (requestTimeoutMs=${requestTimeoutMs}).`);
    this.requestTimeoutMs = requestTimeoutMs;
  }
};
var UpstreamError = class extends ResilientHttpError {
  constructor(status) {
    super(`Upstream returned error status=${status}.`);
    this.status = status;
  }
};

// src/limiter.ts
var ConcurrencyLimiter = class {
  maxInFlight;
  maxQueue;
  enqueueTimeoutMs;
  inFlight = 0;
  queue = [];
  constructor(opts) {
    if (!Number.isFinite(opts.maxInFlight) || opts.maxInFlight <= 0) {
      throw new Error(`maxInFlight must be > 0 (got ${opts.maxInFlight})`);
    }
    if (!Number.isFinite(opts.maxQueue) || opts.maxQueue < 0) {
      throw new Error(`maxQueue must be >= 0 (got ${opts.maxQueue})`);
    }
    if (!Number.isFinite(opts.enqueueTimeoutMs) || opts.enqueueTimeoutMs <= 0) {
      throw new Error(`enqueueTimeoutMs must be > 0 (got ${opts.enqueueTimeoutMs})`);
    }
    this.maxInFlight = opts.maxInFlight;
    this.maxQueue = opts.maxQueue;
    this.enqueueTimeoutMs = opts.enqueueTimeoutMs;
  }
  /**
   * Acquire a permit. Resolves once you are allowed to proceed.
   * MUST be followed by `release()` exactly once.
   */
  acquire() {
    if (this.inFlight < this.maxInFlight) {
      this.inFlight += 1;
      return Promise.resolve();
    }
    if (this.maxQueue === 0 || this.queue.length >= this.maxQueue) {
      return Promise.reject(new QueueFullError(this.maxQueue));
    }
    return new Promise((resolve, reject) => {
      const timer = setTimeout(() => {
        const idx = this.queue.findIndex((w) => w.resolve === resolve);
        if (idx >= 0) {
          const [w] = this.queue.splice(idx, 1);
          clearTimeout(w.timer);
        }
        reject(new QueueTimeoutError(this.enqueueTimeoutMs));
      }, this.enqueueTimeoutMs);
      this.queue.push({ resolve, reject, timer });
    });
  }
  /**
   * Release a permit. Always call this in a `finally` block.
   */
  release() {
    if (this.inFlight <= 0) {
      throw new Error("release() called when inFlight is already 0");
    }
    const next = this.queue.shift();
    if (next) {
      clearTimeout(next.timer);
      next.resolve();
      return;
    }
    this.inFlight -= 1;
  }
  snapshot() {
    return {
      inFlight: this.inFlight,
      queueDepth: this.queue.length,
      maxInFlight: this.maxInFlight,
      maxQueue: this.maxQueue
    };
  }
};

// src/http.ts
var import_undici = require("undici");
function normalizeHeaders(headers) {
  const out = {};
  if (!headers) return out;
  for (const [k, v] of Object.entries(headers)) {
    if (Array.isArray(v)) out[k.toLowerCase()] = v.join(", ");
    else if (typeof v === "string") out[k.toLowerCase()] = v;
    else out[k.toLowerCase()] = String(v);
  }
  return out;
}
async function doHttpRequest(req, requestTimeoutMs) {
  const ac = new AbortController();
  const timer = setTimeout(() => ac.abort(), requestTimeoutMs);
  try {
    const res = await (0, import_undici.request)(req.url, {
      method: req.method,
      headers: req.headers,
      body: req.body,
      signal: ac.signal
    });
    const body = await res.body.arrayBuffer();
    return {
      status: res.statusCode,
      headers: normalizeHeaders(res.headers),
      body: new Uint8Array(body)
    };
  } catch (err) {
    if (err?.name === "AbortError") {
      throw new RequestTimeoutError(requestTimeoutMs);
    }
    throw err;
  } finally {
    clearTimeout(timer);
  }
}

// src/client.ts
function normalizeUrlForKey(rawUrl) {
  const u = new URL(rawUrl);
  u.hostname = u.hostname.toLowerCase();
  const isHttpDefault = u.protocol === "http:" && u.port === "80";
  const isHttpsDefault = u.protocol === "https:" && u.port === "443";
  if (isHttpDefault || isHttpsDefault) u.port = "";
  return u.toString();
}
function defaultMicroCacheKeyFn(req) {
  return `GET ${normalizeUrlForKey(req.url)}`;
}
function genRequestId() {
  return `${Date.now().toString(36)}-${Math.random().toString(36).slice(2, 10)}`;
}
function sleep(ms) {
  return new Promise((r) => setTimeout(r, ms));
}
function clamp(n, lo, hi) {
  return Math.max(lo, Math.min(hi, n));
}
var ResilientHttpClient = class extends import_node_events.EventEmitter {
  constructor(opts) {
    super();
    this.opts = opts;
    this.limiter = new ConcurrencyLimiter({
      maxInFlight: opts.maxInFlight,
      maxQueue: opts.maxQueue,
      enqueueTimeoutMs: opts.enqueueTimeoutMs
    });
    this.requestTimeoutMs = opts.requestTimeoutMs;
    const mc = opts.microCache;
    if (mc?.enabled) {
      const retry = mc.retry ? {
        maxAttempts: mc.retry.maxAttempts ?? 3,
        baseDelayMs: mc.retry.baseDelayMs ?? 50,
        maxDelayMs: mc.retry.maxDelayMs ?? 200,
        retryOnStatus: mc.retry.retryOnStatus ?? [429, 502, 503, 504]
      } : void 0;
      this.microCache = {
        enabled: true,
        ttlMs: mc.ttlMs ?? 1e3,
        maxStaleMs: mc.maxStaleMs ?? 1e4,
        maxEntries: mc.maxEntries ?? 500,
        maxWaiters: mc.maxWaiters ?? 1e3,
        followerTimeoutMs: mc.followerTimeoutMs ?? 5e3,
        keyFn: mc.keyFn ?? defaultMicroCacheKeyFn,
        retry
      };
      this.cache = /* @__PURE__ */ new Map();
      this.inFlight = /* @__PURE__ */ new Map();
    }
  }
  limiter;
  requestTimeoutMs;
  microCache;
  cache;
  inFlight;
  microCacheReqCount = 0;
  cleanupEveryNRequests = 100;
  async request(req) {
    if (this.microCache?.enabled && req.method === "GET" && req.body == null) {
      return this.requestWithMicroCache(req);
    }
    return this.existingPipeline(req);
  }
  cloneResponse(res) {
    return {
      status: res.status,
      headers: { ...res.headers },
      body: new Uint8Array(res.body)
    };
  }
  maybeCleanupExpired(cache, maxStaleMs) {
    this.microCacheReqCount++;
    if (this.microCacheReqCount % this.cleanupEveryNRequests !== 0) return;
    const now = Date.now();
    for (const [k, v] of cache.entries()) {
      if (now - v.createdAt > maxStaleMs) cache.delete(k);
    }
  }
  evictIfNeeded(cache, maxEntries) {
    while (cache.size >= maxEntries) {
      const oldestKey = cache.keys().next().value;
      if (!oldestKey) break;
      cache.delete(oldestKey);
    }
  }
  isRetryableStatus(status, retryOnStatus) {
    return retryOnStatus.includes(status);
  }
  computeBackoffMs(attemptIndex, baseDelayMs, maxDelayMs) {
    const exp = baseDelayMs * Math.pow(2, attemptIndex - 1);
    const capped = clamp(exp, baseDelayMs, maxDelayMs);
    const jitter = 0.5 + Math.random();
    return Math.round(capped * jitter);
  }
  async fetchWithLeaderRetry(req) {
    const mc = this.microCache;
    const retry = mc.retry;
    if (!retry) return this.existingPipeline(req);
    const { maxAttempts, baseDelayMs, maxDelayMs, retryOnStatus } = retry;
    let last;
    for (let attempt = 1; attempt <= maxAttempts; attempt++) {
      const res = await this.existingPipeline(req);
      last = res;
      if (this.isRetryableStatus(res.status, retryOnStatus) && attempt < maxAttempts) {
        const delay = this.computeBackoffMs(attempt, baseDelayMs, maxDelayMs);
        this.emit("microcache:retry", {
          url: req.url,
          attempt,
          maxAttempts,
          reason: `status ${res.status}`,
          delayMs: delay
        });
        await sleep(delay);
        continue;
      }
      return res;
    }
    return last;
  }
  /**
   * Window behavior:
   * - 0..ttlMs: return cache (fresh)
   * - ttlMs..maxStaleMs: leader refreshes; others get old value until replaced (stale-while-revalidate)
   * - >maxStaleMs: do not serve old; behave like no cache
   *
   * Follower controls (only when no cache is served):
   * - maxWaiters: cap concurrent followers joining the leader
   * - followerTimeoutMs: shared "join window" from first follower; after it expires, late followers fail fast until leader completes
   */
  async requestWithMicroCache(req) {
    const mc = this.microCache;
    const cache = this.cache;
    const inFlight = this.inFlight;
    this.maybeCleanupExpired(cache, mc.maxStaleMs);
    const key = mc.keyFn(req);
    const now = Date.now();
    const hit0 = cache.get(key);
    if (hit0 && now - hit0.createdAt > mc.maxStaleMs) {
      cache.delete(key);
    }
    const hit = cache.get(key);
    if (hit && now < hit.expiresAt) {
      return this.cloneResponse(hit.value);
    }
    const group = inFlight.get(key);
    if (group) {
      const h = cache.get(key);
      const staleAllowed = !!h && now - h.createdAt <= mc.maxStaleMs;
      if (h && staleAllowed) {
        return this.cloneResponse(h.value);
      }
      const age = now - group.windowStartMs;
      if (age > mc.followerTimeoutMs) {
        const err = new Error(`Follower window closed for key=${key}`);
        err.name = "FollowerWindowClosedError";
        throw err;
      }
      if (group.waiters >= mc.maxWaiters) {
        const err = new Error(`Too many followers for key=${key}`);
        err.name = "TooManyWaitersError";
        throw err;
      }
      group.waiters += 1;
      try {
        const res = await group.promise;
        return this.cloneResponse(res);
      } finally {
        group.waiters -= 1;
      }
    }
    const prev = cache.get(key);
    const prevStaleAllowed = !!prev && now - prev.createdAt <= mc.maxStaleMs;
    const promise = (async () => {
      const res = await this.fetchWithLeaderRetry(req);
      if (res.status >= 200 && res.status < 300) {
        this.evictIfNeeded(cache, mc.maxEntries);
        const t = Date.now();
        cache.set(key, {
          value: this.cloneResponse(res),
          createdAt: t,
          expiresAt: t + mc.ttlMs
        });
      }
      return res;
    })();
    const newGroup = {
      promise,
      windowStartMs: Date.now(),
      waiters: 0
    };
    inFlight.set(key, newGroup);
    try {
      const res = await promise;
      if (!(res.status >= 200 && res.status < 300) && prev && prevStaleAllowed) {
        return this.cloneResponse(prev.value);
      }
      return this.cloneResponse(res);
    } catch (err) {
      if (prev && prevStaleAllowed) {
        this.emit("microcache:refresh_failed", { key, url: req.url, error: err });
        return this.cloneResponse(prev.value);
      }
      throw err;
    } finally {
      inFlight.delete(key);
    }
  }
  async existingPipeline(req) {
    const requestId = genRequestId();
    try {
      await this.limiter.acquire();
    } catch (err) {
      this.emit("request:rejected", { requestId, request: req, error: err });
      throw err;
    }
    const start = Date.now();
    this.emit("request:start", { requestId, request: req });
    try {
      const res = await doHttpRequest(req, this.requestTimeoutMs);
      const durationMs = Date.now() - start;
      this.emit("request:success", { requestId, request: req, status: res.status, durationMs });
      return res;
    } catch (err) {
      const durationMs = Date.now() - start;
      this.emit("request:failure", { requestId, request: req, error: err, durationMs });
      throw err;
    } finally {
      this.limiter.release();
    }
  }
  snapshot() {
    const s = this.limiter.snapshot();
    return { inFlight: s.inFlight, queueDepth: s.queueDepth };
  }
};
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  QueueFullError,
  QueueTimeoutError,
  RequestTimeoutError,
  ResilientHttpClient,
  ResilientHttpError,
  UpstreamError
});
//# sourceMappingURL=index.cjs.map